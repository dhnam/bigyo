"""
bigyo (비교: comparison)
========================

Python library for side-by-side diff in terminal.
use difflib as its engine.
Supports beautiful output with multi-width or zero-width character.

:date: 2022-12-09
:Author: LegenDUST
:Version: 0.0.1
"""

import difflib
from typing import Sequence, Iterator
from abc import ABC, abstractmethod
from wcwidth import wcswidth, wcwidth


class BigyoStratagy(ABC):
    """
    Abstract Base Bigyo Stratagy.
    Bigyo stratagy defines how :class:`Bigyo` generates side by side comparison lines.

    :param sep: Separator for separate two compared lines, defaults to "|"
    :param mark_unchanged: Flag to decide :class:`Bigyo` whether it passes line as-is or mark unchanged line with "  " indicator
    """
    def __init__(self, sep: str="|", mark_unchanged: bool=False):
        """Constructor method
        """
        self.maxlen = -1
        self.sep = sep
        self.mark_unchanged = mark_unchanged
    

    def join_with_spaces(self, left: str, right: str) -> str:
        """
        Joins two string with separater `self.sep`.
        Spacing is added to make it look nicer.
        :param left: Left string to be printed
        :param right: Right string to be printed
        :return: joined string with appropriate spacing and separater
        """
        return f"{left}{' '*(self.maxlen - wcswidth(left))}{self.sep}{right}" + "\n"

    @abstractmethod
    def next_line(self, *, left: str="", right: str="", left_replace: str | None=None, right_replace: str | None=None) -> Iterator[str]:
        """
        Generator to actually build comparison lines.

        :param left: Left string compared
        :param right: Right string compared
        :param left_replace: Diff line generated by :class:`Bigyo` for :param:`left`, defaults to None
        :param right_replace: Diff line generated by :class:`Bigyo` for :param:`right`, defaults to None
        :return: Iterator containing new line generated as stratagy
        """
        pass

class SimpleBigyoStratagy(BigyoStratagy):
    def next_line(self, *, left: str="", right: str="", left_replace: str | None=None, right_replace: str | None=None) -> Iterator[str]:
        def replace_unicode_match(string: str, replace: str) -> str:
            ret = ""
            for next_char, next_replace in zip(string, replace):
                if wcwidth(next_char) == 1:
                    ret += next_replace
                elif wcwidth(next_char) == 2:
                    ret += next_replace * 2
            return ret
        yield self.join_with_spaces(left, right)
        if any([left_replace, right_replace]):
            yield self.join_with_spaces(
                "" if left_replace is None else replace_unicode_match(left, left_replace),
                "" if right_replace is None else replace_unicode_match(right, right_replace),
                )


class OnelineBigyoStratagy(BigyoStratagy):
    def __init__(self, sep="|", mark_unchanged=True, add_mark: tuple[str, str]=("<", ">"), delete_mark: tuple[str, str]=(">", "<")):
        super().__init__(sep, mark_unchanged)
        self.add_mark = add_mark
        self.delete_mark = delete_mark
    
    def next_line(self, *, left: str = "", right: str = "", left_replace: str | None = None, right_replace: str | None = None) -> Iterator[str]:
        DELETE = 0
        ADD = 1
        def combine_str(string, op, place:list[bool] = None):
            combined: str = ""
            if place is None:
                place = [True] * len(string)
            assert len(place) == len(string)
            in_editing: bool = False
            for next_char, is_combined in zip(string, place):
                if is_combined != in_editing:
                    if not in_editing:
                        combined += self.delete_mark[0] if op == DELETE else self.add_mark[0]
                    else:
                        combined += self.delete_mark[1] if op == DELETE else self.add_mark[1]
                    in_editing = not in_editing
                combined += next_char
            if in_editing:
                combined += self.delete_mark[1] if op == DELETE else self.add_mark[1]
            return combined

        processed: list[str] = ["", ""]
        for i, (string, cue) in enumerate([(left, left_replace), (right, right_replace)]):
            if string == "":
                processed[i] = ""
                continue
            line_cue, string = string[:2], string[2:]
            cue_place = [False] * len(string)
            if cue is None:
                cue_place = [True] * len(string)
            else:
                cue = cue[2:]
                for j, next_char in enumerate(cue):
                    cue_place[j] = (next_char != " ")
            match line_cue:
                case "  ":
                    processed[i] = string
                case "- ":
                    processed[i] = combine_str(string, DELETE, cue_place)
                case "+ ":
                    processed[i] = combine_str(string, ADD, cue_place)
        yield self.join_with_spaces(*processed)


class Bigyo:
    def __init__(self, bigyo_stratagy: BigyoStratagy | None=None):
        self._recent_indicator: str = ''
        self._recent_lines: list[str] = []
        if bigyo_stratagy is None:
            bigyo_stratagy = SimpleBigyoStratagy()
        self.bigyo_stratagy = bigyo_stratagy

    def bigyo(self, a: Sequence[str], b: Sequence[str]) -> Iterator[str]:
        self.bigyo_stratagy.maxlen = max(map(wcswidth, map(lambda x: x.strip("\n"), a))) + 2
        lines = difflib.Differ().compare(a, b)

        # new line patterns: " ", "-", "+", "-?+", "-+?", "-?+?"
        # tokens: " ", "-", "+", "?"
        def completed_pattern(indicator: str) -> Iterator[str]:
            assert self._recent_indicator.startswith(indicator)
            match indicator:
                case " ":
                    yield from self.bigyo_stratagy.next_line(a=self._recent_lines[0], b=self._recent_lines[0])
                    self._recent_indicator = self._recent_indicator[1:]
                    self._recent_lines = self._recent_lines[1:]
                case "+":
                    yield from self.bigyo_stratagy.next_line(b=self._recent_lines[0])
                    self._recent_indicator = self._recent_indicator[1:]
                    self._recent_lines = self._recent_lines[1:]
                case "-":
                    yield from self.bigyo_stratagy.next_line(a=self._recent_lines[0])
                    self._recent_indicator = self._recent_indicator[1:]
                    self._recent_lines = self._recent_lines[1:]
                case "-?+":
                    if self.bigyo_stratagy.mark_unchanged:
                        self._recent_lines[2] = " " + self._recent_lines[2][1:]
                    yield from self.bigyo_stratagy.next_line(a=self._recent_lines[0], b=self._recent_lines[2], a_replace=self._recent_lines[1])
                    self._recent_indicator = self._recent_indicator[3:]
                    self._recent_lines = self._recent_lines[3:]
                case "-+?":
                    if self.bigyo_stratagy.mark_unchanged:
                        self._recent_lines[0] = " " + self._recent_lines[0][1:]
                    yield from self.bigyo_stratagy.next_line(a=self._recent_lines[0], b=self._recent_lines[1], b_replace=self._recent_lines[2])
                    self._recent_indicator = self._recent_indicator[3:]
                    self._recent_lines = self._recent_lines[3:]
                case "-?+?":
                    yield from self.bigyo_stratagy.next_line(a=self._recent_lines[0], b=self._recent_lines[2], a_replace=self._recent_lines[1], b_replace=self._recent_lines[3])
                    self._recent_indicator = self._recent_indicator[4:]
                    self._recent_lines = self._recent_lines[4:]

        for next_line in lines:
            next_line = next_line.strip("\n")
            self._recent_indicator += next_line[0]
            self._recent_lines.append(next_line)
            
            match self._recent_indicator:
                case " ":
                    yield from completed_pattern(" ")
                case "+":
                    yield from completed_pattern("+")
                case "- ":
                    yield from completed_pattern("-")
                    yield from completed_pattern(" ")
                case "--":
                    yield from completed_pattern("-")
                case "-+ ":
                    yield from completed_pattern("-")
                    yield from completed_pattern("+")
                    yield from completed_pattern(" ")
                case "-+-":
                    yield from completed_pattern("-")
                    yield from completed_pattern("+")
                case "-++":
                    yield from completed_pattern("-")
                    yield from completed_pattern("+")
                    yield from completed_pattern("+")
                case "-+?":
                    yield from completed_pattern("-+?")
                case "-? " | "-?-" | "-??":
                    raise Exception(self._recent_indicator)
                case "-?+ ":
                    yield from completed_pattern("-?+")
                    yield from completed_pattern(" ")
                case "-?+-":
                    yield from completed_pattern("-?+")
                case "-?++":
                    yield from completed_pattern("-?+")
                    yield from completed_pattern("+")
                case "-?+?":
                    yield from completed_pattern("-?+?")
        if self._recent_indicator != "":
            yield from completed_pattern(self._recent_indicator)