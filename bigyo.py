"""
bigyo (비교: comparison)
========================

Python library for side-by-side diff in terminal.

use difflib as its engine.

Supports beautiful output with multi-width or zero-width character.

:date: 2022-12-15
:Author: LegenDUST
:Version: 0.1.0
"""

import difflib
from typing import Sequence, Iterator, Optional
from abc import ABC, abstractmethod
from wcwidth import wcswidth, wcwidth


class BigyoRenderer(ABC):
    """
    Abstract Base Bigyo rendering strategy.

    Bigyo rendering strategy defines how :class:`Bigyo` generates side by side comparison lines.

    :param sep: Separator for separate two compared lines, defaults to "|"
    :param mark_unchanged: Flag to decide :class:`Bigyo` whether it passes line as-is or mark unchanged line with "  " indicator, defaultes to False
    """
    def __init__(self, sep: str="|", mark_unchanged: bool=False):
        self.maxlen = -1
        self.sep = sep
        self.mark_unchanged = mark_unchanged
    

    def join_with_spaces(self, left: str, right: str) -> str:
        """
        Joins two string with separater `self.sep`.

        Spacing is added to make it look nicer.

        :param left: Left string to be printed
        :param right: Right string to be printed
        :return: joined string with appropriate spacing and separater
        """
        return f"{left}{' '*(self.maxlen - wcswidth(left))}{self.sep}{right}" + "\n"

    @abstractmethod
    def render(self, *, left: str="", right: str="", left_replace: Optional[str]=None, right_replace: Optional[str]=None) -> str:
        """
        Function to actually build comparison lines.

        :param left: Left string compared
        :param right: Right string compared
        :param left_replace: Diff line generated by :class:`Bigyo` for :param:`left`, defaults to None
        :param right_replace: Diff line generated by :class:`Bigyo` for :param:`right`, defaults to None
        :return: Compared line
        """

class SimpleBigyoRenderer(BigyoRenderer):
    """
    Simple Bigyo rendering stratgy.

    Will produce side-by-side comparison, with difference is displayed as separated line.

    :param sep: Separator for separate two compared lines, defaults to "|"
    :param mark_unchanged: Flag to decide :class:`Bigyo` whether it passes line as-is or mark unchanged line with "  " indicator, defaultes to False
    """
    def render(self, *, left: str="", right: str="", left_replace: Optional[str]=None, right_replace: Optional[str]=None) -> str:
        def replace_unicode_match(string: str, replace: str) -> str:
            ret = ""
            for next_char, next_replace in zip(string, replace):
                if wcwidth(next_char) == 1:
                    ret += next_replace
                elif wcwidth(next_char) == 2:
                    ret += next_replace * 2
            return ret
        
        diff_line = self.join_with_spaces(left, right)
        if any([left_replace, right_replace]):
            diff_line += self.join_with_spaces(
                "" if left_replace is None else replace_unicode_match(left, left_replace),
                "" if right_replace is None else replace_unicode_match(right, right_replace),
                )
        return diff_line


class OnelineBigyoRenderer(BigyoRenderer):
    """
    One-line Bigyo rendering stratgy.

    Will produce side-by-side comparison, with difference is displayed in-line with marks.

    Mark is changable by __init__ method.

    Default mark is ("<", ">") for added difference, (">", "<") for removed difference.

    So <added difference will be shown like this>, and >removed difference will be shown like this<.

    :param sep: Separator for separate two compared lines, defaults to "|"
    :param mark_unchanged: Flag to decide :class:`Bigyo` whether it passes line as-is or mark unchanged line with "  " indicator, defaultes to True
    :param add_mark: Characters to mark range of added difference, defaultes to ("<", ">")
    :param delete_mark: Characters to mark range of removed difference, defaultes to (">", "<")
    """
    def __init__(self, sep="|", mark_unchanged=True, add_mark: tuple[str, str]=("<", ">"), delete_mark: tuple[str, str]=(">", "<")):
        super().__init__(sep, mark_unchanged)
        self.add_mark = add_mark
        self.delete_mark = delete_mark

    def render(self, *, left: str = "", right: str = "", left_replace: Optional[str] = None, right_replace: Optional[str] = None) -> str:
        DELETE = 0
        ADD = 1
        def combine_str(string, op, place:list[bool] = None):
            combined: str = ""
            if place is None:
                place = [True] * len(string)
            assert len(place) == len(string)
            in_editing: bool = False
            for next_char, is_combined in zip(string, place):
                if is_combined != in_editing:
                    if not in_editing:
                        combined += self.delete_mark[0] if op == DELETE else self.add_mark[0]
                    else:
                        combined += self.delete_mark[1] if op == DELETE else self.add_mark[1]
                    in_editing = not in_editing
                combined += next_char
            if in_editing:
                combined += self.delete_mark[1] if op == DELETE else self.add_mark[1]
            return combined

        processed: list[str] = ["", ""]
        for i, (string, cue) in enumerate([(left, left_replace), (right, right_replace)]):
            if string == "":
                processed[i] = ""
                continue
            line_cue, string = string[:2], string[2:]
            cue_place = [False] * len(string)
            if cue is None:
                cue_place = [True] * len(string)
            else:
                cue = cue[2:]
                for j, next_char in enumerate(cue):
                    cue_place[j] = (next_char != " ")

            if line_cue == "  ":
                processed[i] = string
            elif line_cue == "- ":
                processed[i] = combine_str(string, DELETE, cue_place)
            elif line_cue == "+ ":
                processed[i] = combine_str(string, ADD, cue_place)
        return self.join_with_spaces(*processed)


class Bigyo:
    """
    Bigyo
    =====

    Bigyo (ko: 비교, comparison) is class for side-by-side comparison, using `difflib` as its engine.

    Simply replace
       difflib.Differ().compare(a, b)
    to
       Bigyo().compare()
    and you'll get nice side-by-side comparison.

    :param bigyo_renderer: Bigyo rendering strategy, which decides way to render comparison.
    It can be :class:`BigyoRenderer` object, or None (which uses :class:`SimpleBigyoRenderer`), defaults to None
    """
    def __init__(self, bigyo_renderer: Optional[BigyoRenderer]=None):
        self._recent_indicator: str = ''
        self._recent_lines: list[str] = []
        if bigyo_renderer is None:
            bigyo_renderer = SimpleBigyoRenderer()
        self.bigyo_renderer = bigyo_renderer

    # new line patterns: " ", "-", "+", "-+", "-?+", "-+?", "-?+?"
    # tokens: " ", "-", "+", "?"
    def _completed_pattern(self, indicator: str) -> Iterator[str]:
        assert self._recent_indicator.startswith(indicator)
        if indicator == " ":
            yield self.bigyo_renderer.render(
                left=self._recent_lines[0],
                right=self._recent_lines[0],
                )
            self._recent_indicator = self._recent_indicator[1:]
            self._recent_lines = self._recent_lines[1:]
        elif indicator == "+":
            yield self.bigyo_renderer.render(
                right=self._recent_lines[0],
                )
            self._recent_indicator = self._recent_indicator[1:]
            self._recent_lines = self._recent_lines[1:]
        elif indicator == "-":
            yield self.bigyo_renderer.render(
                left=self._recent_lines[0],
                )
            self._recent_indicator = self._recent_indicator[1:]
            self._recent_lines = self._recent_lines[1:]
        elif indicator == "-+":
            yield self.bigyo_renderer.render(
                left=self._recent_lines[0],
                right=self._recent_lines[1],
                )
            self._recent_indicator = self._recent_indicator[2:]
            self._recent_lines = self._recent_lines[2:]
        elif indicator == "-?+":
            if self.bigyo_renderer.mark_unchanged:
                self._recent_lines[2] = " " + self._recent_lines[2][1:]
            yield self.bigyo_renderer.render(
                left=self._recent_lines[0],
                right=self._recent_lines[2],
                left_replace=self._recent_lines[1],
                )
            self._recent_indicator = self._recent_indicator[3:]
            self._recent_lines = self._recent_lines[3:]
        elif indicator == "-+?":
            if self.bigyo_renderer.mark_unchanged:
                self._recent_lines[0] = " " + self._recent_lines[0][1:]
            yield self.bigyo_renderer.render(
                left=self._recent_lines[0],
                right=self._recent_lines[1],
                right_replace=self._recent_lines[2],
                )
            self._recent_indicator = self._recent_indicator[3:]
            self._recent_lines = self._recent_lines[3:]
        elif indicator == "-?+?":
            yield self.bigyo_renderer.render(
                left=self._recent_lines[0],
                right=self._recent_lines[2],
                left_replace=self._recent_lines[1],
                right_replace=self._recent_lines[3],
                )
            self._recent_indicator = self._recent_indicator[4:]
            self._recent_lines = self._recent_lines[4:]

    def compare(self, left: Sequence[str], right: Sequence[str]) -> Iterator[str]:
        """
        Generator for generating side-by-side comparison.

        :param left: Left sequence to compare
        :param right: Right sequence to compare
        :return: Iterator, where `next()` call returns line with its difference.
        """
        # TODO reduce memory usage of the line? Is there really big memory usage in the line?
        self.bigyo_renderer.maxlen = max(map(wcswidth, map(lambda x: x.strip("\n"), left))) + 2
        lines = difflib.Differ().compare(left, right)

        for next_line in lines:
            next_line = next_line.strip("\n")
            self._recent_indicator += next_line[0]
            self._recent_lines.append(next_line)

            if self._recent_indicator == " ":
                yield from self._completed_pattern(" ")
            elif self._recent_indicator == "+":
                yield from self._completed_pattern("+")
            elif self._recent_indicator == "- ":
                yield from self._completed_pattern("-")
                yield from self._completed_pattern(" ")
            elif self._recent_indicator == "--":
                yield from self._completed_pattern("-")
            elif self._recent_indicator == "-+ ":
                yield from self._completed_pattern("-+")
                yield from self._completed_pattern(" ")
            elif self._recent_indicator == "-+-":
                yield from self._completed_pattern("-+")
            elif self._recent_indicator == "-++":
                yield from self._completed_pattern("-+")
                yield from self._completed_pattern("+")
            elif self._recent_indicator == "-+?":
                yield from self._completed_pattern("-+?")
            elif self._recent_indicator in ("-? ",  "-?-" , "-??"):
                raise Exception(self._recent_indicator)
            elif self._recent_indicator == "-?+ ":
                yield from self._completed_pattern("-?+")
                yield from self._completed_pattern(" ")
            elif self._recent_indicator == "-?+-":
                yield from self._completed_pattern("-?+")
            elif self._recent_indicator == "-?++":
                yield from self._completed_pattern("-?+")
                yield from self._completed_pattern("+")
            elif self._recent_indicator == "-?+?":
                yield from self._completed_pattern("-?+?")

        if self._recent_indicator != "":
            yield from self._completed_pattern(self._recent_indicator)

    def comparison_string(self, left: Sequence[str], right: Sequence[str]) -> str:
        """
        Return full compared string at once.

        Is just ``return ''.join(self.compare(left, right))``. Guess it will quite comes in handy.
        
        :param left: Left sequence to compare
        :param right: Right sequence to compare
        """
        return ''.join(self.compare(left, right))

if __name__ == "__main__":
    a = ["Hello, World\n", "안녕, 세계"]
    b = ["Helo, Wold!\n", "안넝, 새개!"]
    print(Bigyo().comparison_string(a, b))